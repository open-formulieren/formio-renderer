import {ArgsTable, Canvas, Meta, Story} from '@storybook/addon-docs';
import {CallbacksContext, RenderComponent, RenderForm} from "./renderer";
import {FORMIO_EXAMPLE} from "../../fixtures";

<Meta title="Libraries / Renderer" component={RenderForm} />

export const RenderFormTemplate = (args) => <RenderForm {...args} />

RenderForm
===

Renderer for rendering a Form.io configuration passed as form. Iterates over children and returns
`React.ReactElement` containing the rendered form.

Configuring custom components
---

`RenderContext` expects a `IRenderConfiguration` which is expected to be available via
`useContext(RenderContext)`. The IRenderConfiguration's `components` entry should contain a
mapping between a component type and the (React) component / Function. Overriding RenderContext
allows for specifying components.

All components receive the `IComponentProps` as props containing the required context to render
the component. Components should return a React.ReactElement.

Context
---
Rendering a form relies on certain contexts to be provided.

 - Expects `CallbackContext` to be available.
 - Expects `RenderContext` to be available.
 - Expects `SubmissionContext` to be available.

```tsx
<CallbacksContext.Provider value={ICallbackConfiguration}>
  <RenderContext.Provider value={IRenderConfiguration}>
    <SubmissionContext.Provider value={ISubmission}>
      <RenderForm form={form} />
    </SubmissionContext.Provider>
  </RenderContext.Provider>
</CallbacksContext.Provider>
```

<Canvas>
  <Story name="RenderForm" args={{form: {display: 'form', components: FORMIO_EXAMPLE}}}>
    {RenderFormTemplate.bind({})}
  </Story>
</Canvas>

<ArgsTable of={RenderForm}/>


export const RenderComponentTemplate = (args) => <RenderComponent {...args} />

Component
===

Renderer for rendering a Form.io component passed as component. Iterates over children (and
columns) and returns a `React.ReactElement` containing the rendered component.

Columns
---

In certain cases a component (is not defined as) a component but something else (e.g. a column)
We deal with this edge cases by extending the schema with a custom (component) type allowing it
to be picked up by `useComponentType` and rendered.

This allows for components to remain simple and increases compatibility with existing design
systems.

Configuring custom components
---

`RenderContext` expects a `IRenderConfiguration` which is expected to be available via
`useContext(RenderContext)`. The IRenderConfiguration's `components` entry should contain a
mapping between a component type and the (React) component / Function. Overriding RenderContext
allows for specifying components.

Context
---
Rendering a form relies on certain contexts to be provided.

 - Expects `CallbackContext` to be available.
 - Expects `RenderContext` to be available.
 - Expects `SubmissionContext` to be available.

```tsx
<CallbacksContext.Provider value={ICallbackConfiguration}>
  <RenderContext.Provider value={IRenderConfiguration}>
    <SubmissionContext.Provider value={ISubmission}>
      <RenderComponent component={component} />
    </SubmissionContext.Provider>
  </RenderContext.Provider>
</CallbacksContext.Provider>
```

<Canvas>
  <Story name="RenderComponent" args={{component: FORMIO_EXAMPLE[0]}}>
    {RenderComponentTemplate.bind({})}
  </Story>
</Canvas>

<ArgsTable of={RenderComponent}/>

