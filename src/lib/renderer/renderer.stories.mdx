import {ArgsTable, Canvas, Meta, Story} from '@storybook/addon-docs';
import {expect} from "@storybook/jest";

import {
  CallbacksContext,
  DEFAULT_RENDER_CONFIGURATION,
  RenderComponent,
  RenderContext,
  RenderForm,
  SubmissionContext
} from "./renderer";
import {FORMIO_EXAMPLE} from "../../fixtures";
import {useState} from "react";
import {FORMIO_CONDITIONAL} from "../../fixtures/formio/formio-conditional";
import {within} from "@testing-library/dom";
import {userEvent} from "@storybook/testing-library";

<Meta title="Libraries / Renderer" component={RenderForm}/>

export const RenderFormTemplate = (args) => <RenderForm {...args} />

RenderForm
===

Renderer for rendering a Form.io configuration passed as form. Iterates over children and returns
`React.ReactElement` containing the rendered form.

Configuring custom components
---

`RenderContext` expects a `IRenderConfiguration` which is expected to be available via
`useContext(RenderContext)`. The IRenderConfiguration's `components` entry should contain a
mapping between a component type and the (React) component / Function. Overriding RenderContext
allows for specifying components.

All components receive the `IComponentProps` as props containing the required context to render
the component. Components should return a React.ReactElement.

Context
---
Rendering a form relies on certain contexts to be provided.

 - Expects `CallbackContext` to be available.
 - Expects `RenderContext` to be available.
 - Expects `SubmissionContext` to be available.

```tsx
<CallbacksContext.Provider value={ICallbackConfiguration}>
  <RenderContext.Provider value={IRenderConfiguration}>
    <SubmissionContext.Provider value={ISubmission}>
      <RenderForm form={form} />
    </SubmissionContext.Provider>
  </RenderContext.Provider>
</CallbacksContext.Provider>
```

<Canvas>
  <Story name="RenderForm" args={{form: {display: 'form', components: FORMIO_EXAMPLE}}}>
    {RenderFormTemplate.bind({})}
  </Story>
</Canvas>

<ArgsTable of={RenderForm}/>


export const RenderComponentTemplate = (args) => <RenderComponent {...args} />

Component
===

Renderer for rendering a Form.io component passed as component. Iterates over children (and
columns) and returns a `React.ReactElement` containing the rendered component.

Columns
---

In certain cases a component (is not defined as) a component but something else (e.g. a column)
We deal with this edge cases by extending the schema with a custom (component) type allowing it
to be picked up by `useComponentType` and rendered.

This allows for components to remain simple and increases compatibility with existing design
systems.

Configuring custom components
---

`RenderContext` expects a `IRenderConfiguration` which is expected to be available via
`useContext(RenderContext)`. The IRenderConfiguration's `components` entry should contain a
mapping between a component type and the (React) component / Function. Overriding RenderContext
allows for specifying components.

Context
---
Rendering a form relies on certain contexts to be provided.

 - Expects `CallbackContext` to be available.
 - Expects `RenderContext` to be available.
 - Expects `SubmissionContext` to be available.

```tsx
<CallbacksContext.Provider value={ICallbackConfiguration}>
  <RenderContext.Provider value={IRenderConfiguration}>
    <SubmissionContext.Provider value={ISubmission}>
      <RenderComponent component={component} />
    </SubmissionContext.Provider>
  </RenderContext.Provider>
</CallbacksContext.Provider>
```

<Canvas>
  <Story name="RenderComponent"
         args={{component: FORMIO_EXAMPLE[0], form: {display: "form", components: FORMIO_EXAMPLE}}}>
    {RenderComponentTemplate.bind({})}
  </Story>
</Canvas>

<ArgsTable of={RenderComponent}/>


export const ConditionalLogicTemplate = (args) => (
  <CallbacksContext.Provider value={args.callbacks}>
    <RenderContext.Provider value={args.configuration}>
      <SubmissionContext.Provider value={args.submission}>
        <RenderForm form={args.form}/>
      </SubmissionContext.Provider>
    </RenderContext.Provider>
  </CallbacksContext.Provider>
)

Conditionals
---

Basic Form.io conditional logic (found in the "Advanced" tab) is evaluated during the render
process.

<Canvas>
  <Story
    name="Conditional logic"
    args={{
      configuration: DEFAULT_RENDER_CONFIGURATION,
      form: {
        display: 'form',
        components: FORMIO_CONDITIONAL,
      },
      submission: {
        data: {}
      },
      callbacks: {}
    }}
    decorators={[(Story, args) => {
      const [submissionDataState, setSubmissionDataState] = useState(args.args.submission.data)
      const onChange = (e) => {
        const name = e.target.name
        const value = e.target.value
        setSubmissionDataState({...submissionDataState, [name]: value})
      }
      args.args.submission.data = submissionDataState
      args.args.callbacks.onChange = onChange
      return Story();
    }]}
    play={async ({canvasElement}) => {
      const canvas = within(canvasElement);
      const input = canvas.getByLabelText("Favorite animal", {
        selector: 'input',
      });
      expect(await canvas.queryByText("Please motivate why \"cat\" is your favorite animal...")).toBeNull()
      expect(await canvas.queryByText("Please motivate why \"dog\" is your favorite animal...")).toBeNull()
      expect(await canvas.queryByText("Please enter you favorite animal.")).toBeTruthy()
      expect(await canvas.queryByText("Have you tried \"cat\"?")).toBeTruthy()
      expect(await canvas.queryByText("Have you tried \"dog\"?")).toBeTruthy()
      await userEvent.type(input, 'horse', {delay: 100});
      expect(await canvas.queryByText("Please motivate why \"cat\" is your favorite animal...")).toBeNull()
      expect(await canvas.queryByText("Please motivate why \"dog\" is your favorite animal...")).toBeNull()
      expect(await canvas.queryByText("Please enter you favorite animal.")).toBeFalsy()
      expect(await canvas.queryByText("Have you tried \"cat\"?")).toBeTruthy()
      expect(await canvas.queryByText("Have you tried \"dog\"?")).toBeTruthy()
      await userEvent.clear(input);
      await userEvent.type(input, 'cat', {delay: 100});
      expect(await canvas.queryByText("Please motivate why \"cat\" is your favorite animal...")).toBeTruthy()
      expect(await canvas.queryByText("Please motivate why \"dog\" is your favorite animal...")).toBeNull()
      expect(await canvas.queryByText("Please enter you favorite animal.")).toBeFalsy()
      expect(await canvas.queryByText("Have you tried \"cat\"?")).toBeFalsy()
      expect(await canvas.queryByText("Have you tried \"dog\"?")).toBeTruthy()
      await userEvent.clear(input);
      await userEvent.type(input, 'dog', {delay: 100});
      expect(await canvas.queryByText("Please motivate why \"cat\" is your favorite animal...")).toBeNull()
      expect(await canvas.queryByText("Please motivate why \"dog\" is your favorite animal...")).toBeTruthy()
      expect(await canvas.queryByText("Please enter you favorite animal.")).toBeFalsy()
      expect(await canvas.queryByText("Have you tried \"cat\"?")).toBeTruthy()
      expect(await canvas.queryByText("Have you tried \"dog\"?")).toBeFalsy()
      await userEvent.clear(input);
      expect(await canvas.queryByText("Please motivate why \"cat\" is your favorite animal...")).toBeNull()
      expect(await canvas.queryByText("Please motivate why \"dog\" is your favorite animal...")).toBeNull()
      expect(await canvas.queryByText("Please enter you favorite animal.")).toBeTruthy()
      expect(await canvas.queryByText("Have you tried \"cat\"?")).toBeTruthy()
      expect(await canvas.queryByText("Have you tried \"dog\"?")).toBeTruthy()
    }}>
    {ConditionalLogicTemplate.bind({})}
  </Story>
</Canvas>
