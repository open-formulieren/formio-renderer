import ofTokens from '@open-formulieren/design-tokens/dist/tokens';
import {ArgTypes, Canvas, Controls, Meta} from '@storybook/addon-docs/blocks';
import TokensTable from 'design-token-editor/lib/esm/TokensTable';

import * as FormioFormStories from './FormioForm.stories';

<Meta of={FormioFormStories} />

# FormioForm

**Quickly jump to**

- [Subscribing to value changes](#subscribing-to-value-changes)
- [Programmatically updating form values](#programmatically-updating-form-values)
- [Programmatically setting form errors](#programmatically-setting-form-errors)
- [Providing the `validatePluginCallback`](#providing-the-validateplugincallback)
- [Props](#props)
- [Theming](#theming)

The `FormioForm` component is high level API of this package. Given a formio form definition (as a
list of component definitions), it renders the form fields for it.

Pass the `values` prop to initialize it, e.g. if you have user input that was persisted in some
backend before. `values` are merged with (and override) the default values extracted for each
component in the definition.

The `onSubmit` callback receives the entered form values when the HTML form is submitted.

<Canvas of={FormioFormStories.Example} />

## Subscribing to value changes

The `onChange` prop receives _every_ value change in the form state, which covers:

- value changes because of user input (selecting a checkbox, typing in a text field...)
- calculated/derived values, e.g. the result of `clearOnHide` which leads to a `values` update.

You get the full `values` object in the callback, where the last call represents the current form
values state. No debouncing or artificial delays are applied - that's left up to the caller if it's
required.

Note that in edit grids the form state is only updated when the edits in an item are saved, not
while the user is typing/changing item field values.

## Programmatically updating form values

The `FormioForm` component supports programmatically setting form values - typically to process
(backend) logic evaluation results. This is available via an imperative `ref`, for example:

```tsx
import {useRef} from 'react';

import FormioForm from '@/open-formulieren/formio-renderer';
import type {FormStateRef} from '@/open-formulieren/formio-renderer/components/FormioForm';

const FormStep: React.FC = () => {
  const form = useRef<FormStateRef>();

  return (
    <>
      <FormioForm
        ref={form}
        components={[{id: 'textfield', type: 'textfield', key: 'textfield', label: 'Text field'}]}
        onSubmit={console.log}
      />
      <button
        type="button"
        onClick={() => {
          form.ref.updateValues({textfield: ''});
        }}
      >
        Reset
      </button>
    </>
  );
};
```

`updateValues` takes an object with updates to apply to the form state. These objects can contain
only the updates, i.e. they can be partial form values. Deeply nested objects are applied
accordingly. Some examples clarify the behaviour:

```ts
const updates1 = {
  foo: {
    bar: 'baz',
  },
};
const updates2 = {
  'foo.bar': 'baz',
};
```

will both set the form component with key `foo.bar` to the value `baz`.

Arrays are assigned as-is - there is no deep merge logic:

```ts
const updates4 = {
  foo: {
    bar: [{name: 'first'}, {name: 'second'}],
  },
};
```

will assign the array `[{name: 'first'}, {name: 'second'}]` to the (editgrid) component with key
`foo.bar`.

For partial updates, use string keys containing the index:

```ts
const updates4 = {
  'foo.bar.1.name': 'updated',
};
```

Results in only the `name` key of the second item being updated.

The behaviour of using `undefined` may appear odd - it will first remove the key from the submission
data entirely, but the key will be added back via the visibility/data reconcilation loop. Any
component that is visible will _always_ have a matching key present in the submission data. Note
that the Open Forms backend doesn't provide a way to pass `undefined` as key values anyway and we
consider the "submission data removal" as something that has no added value.

## Programmatically setting form errors

Setting form errors has the same mechanism as setting form values above. For example:

```tsx
import {useRef} from 'react';

import FormioForm from '@/open-formulieren/formio-renderer';
import type {FormStateRef} from '@/open-formulieren/formio-renderer/components/FormioForm';

const FormStep: React.FC = () => {
  const form = useRef<FormStateRef>();

  return (
    <>
      <FormioForm
        ref={form}
        components={[{id: 'textfield', type: 'textfield', key: 'textfield', label: 'Text field'}]}
        onSubmit={console.log}
      />
      <button
        type="button"
        onClick={() => {
          form.ref.updateErrors({textfield: 'A backend validation error!'});
        }}
      >
        Set errors
      </button>
    </>
  );
};
```

## Providing the `validatePluginCallback`

Many of the Formio component types have been extended to support _plugin_-based backend validation -
this is a mechanism where the backend implements the validation logic which can be called via an API
endpoint. Each plugin has an `identifier`, which is a just a plain string.

Components that call/render the `FormioForm` must provide the `validatePluginCallback` prop which
implements the API endpoint interaction, e.g.:

```ts
const validatePluginCallback = async (plugin: string, value: JSONValue) => {
  const body = {plugin, value};
  const response = await window.fetch(
    '/api/validate',{
      method: 'POST',
      headers: {'Accept': 'application/json', 'Content-Type': 'application/json'},
      body: JSON.stringify(body);
    }
  );
  const responseData = await response.json();
  return responseData.isValid
    ? {valid: true}
    : {valid: false, messages: [responseData.error]};
};
```

The prop is optional - if you don't encounter components with non-empty `validate.plugins`, all will
be fine, but there is a default fallback that fails _everything_ to prevent programming mistakes
from silently allowing invalid values.

## Props

<ArgTypes />

## Theming

The `FormioForm` component itself has no styling, but other components exist that may be relevant.

<TokensTable container={ofTokens} limitTo="of.form-field-container." autoExpand />
